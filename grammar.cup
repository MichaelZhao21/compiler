import java_cup.runtime.*;

terminal    SEMI;
terminal    ASSIGN;
terminal    CLASS;
terminal    FINAL;
terminal    INT;
terminal    BOOL;
terminal    CHAR;
terminal    FLOAT;
terminal    VOID;
terminal    TRUE;
terminal    FALSE;
terminal    IF;
terminal    ELSE;
terminal    WHILE;
terminal    READ;
terminal    PRINTLINE;
terminal    PRINT;
terminal    RETURN;
terminal    INCREMENT;
terminal    DECREMENT;
terminal    MULTIPLY;
terminal    DIVIDE;
terminal    ADD;
terminal    SUBTRACT;
terminal    LT;
terminal    GT;
terminal    LTE;
terminal    GTE;
terminal    EQ;
terminal    NE;
terminal    OR;
terminal    AND;
terminal    LPAREN;
terminal    RPAREN;
terminal    LBRACKET;
terminal    RBRACKET;
terminal    LCURLY;
terminal    RCURLY;
terminal    COMPLEMENT;
terminal    QUESTION;
terminal    COLON;
terminal    COMMA;
terminal    PREFIXPLUS;
terminal    PREFIXMINUS;
terminal    TYPECAST;
terminal    TERNARY;

terminal int        INTEGER_LITERAL;
terminal float      FLOAT_LITERAL;
terminal String     CHAR_LITERAL;
terminal String     STRING_LITERAL;
terminal String     ID;
terminal String     COMMENT;

non terminal Program        program;
non terminal Expression     expression; 
non terminal Expression     binaryExpression;
non terminal Expression     unaryExpression;
non terminal Expression     operandExpression;
non terminal Expression     nameExpression;
non terminal Expression     callExpression;
non terminal ArgumentList   arguments;
non terminal Type           type;

precedence right QUESTION, COLON, TERNARY;
precedence left OR;
precedence left AND;
precedence left NE, EQ;
precedence left LT, GT, LTE, GTE;
precedence left ADD, SUBTRACT;
precedence left MULTIPLY, DIVIDE;
precedence left TYPECAST;
precedence right PREFIXPLUS, PREFIXMINUS, COMPLEMENT, INCREMENT, DECREMENT;

program             ::= expression:e
                        {: RESULT = new Program(e); :}
                        ;

type                ::= INT
                        {: RESULT = new Type("int"); :}
                        |
                        CHAR
                        {: RESULT = new Type("char"); :}
                        |
                        BOOL
                        {: RESULT = new Type("bool"); :}
                        |
                        FLOAT
                        {: RESULT = new Type("float"); :}
                        ;

arguments           ::= expression:e COMMA arguments:a
                        {: RESULT = a.prepend(e); :}
                        |
                        expression:e
                        {: RESULT = new ArgumentList(e); :}
                        ;

expression          ::= binaryExpression:b
                        {: RESULT = b; :}
                        |
                        unaryExpression:u
                        {: RESULT = u; :}
                        |
                        nameExpression:n
                        {: RESULT = n; :}
                        |
                        operandExpression:o
                        {: RESULT = o; :}
                        |
                        callExpression:c
                        {: RESULT = c; :}
                        |
                        LPAREN expression:e RPAREN
                        {: RESULT = new ParenExpression(e); :}
                        |
                        LPAREN type:t RPAREN expression:e
                        {: RESULT = new CastExpression(t, e); :}
                        %prec TYPECAST
                        |
                        LPAREN expression:e1 QUESTION expression:e2 COLON expression:e3 RPAREN
                        {: RESULT = new TernaryExpression(e1, e2, e3); :}
                        ;

binaryExpression    ::= expression:e1 ADD expression:e2
                        {: RESULT = new BinaryExpression(e1, "+", e2); :}
                        |
                        expression:e1 SUBTRACT expression:e2
                        {: RESULT = new BinaryExpression(e1, "-", e2); :}
                        |
                        expression:e1 MULTIPLY expression:e2
                        {: RESULT = new BinaryExpression(e1, "*", e2); :}
                        |
                        expression:e1 DIVIDE expression:e2
                        {: RESULT = new BinaryExpression(e1, "/", e2); :}
                        |
                        expression:e1 LT expression:e2
                        {: RESULT = new BinaryExpression(e1, "<", e2); :}
                        |
                        expression:e1 GT expression:e2
                        {: RESULT = new BinaryExpression(e1, ">", e2); :}
                        |
                        expression:e1 LTE expression:e2
                        {: RESULT = new BinaryExpression(e1, "<=", e2); :}
                        |
                        expression:e1 GTE expression:e2
                        {: RESULT = new BinaryExpression(e1, ">=", e2); :}
                        |
                        expression:e1 EQ expression:e2
                        {: RESULT = new BinaryExpression(e1, "==", e2); :}
                        |
                        expression:e1 NE expression:e2
                        {: RESULT = new BinaryExpression(e1, "<>", e2); :}
                        |
                        expression:e1 OR expression:e2
                        {: RESULT = new BinaryExpression(e1, "||", e2); :}
                        |
                        expression:e1 AND expression:e2
                        {: RESULT = new BinaryExpression(e1, "&&", e2); :}
                        ;

unaryExpression     ::= COMPLEMENT expression:e
                        {: RESULT = new UnaryExpression("~", e); :}
                        |
                        ADD expression:e
                        {: RESULT = new UnaryExpression("+", e); :}
                        %prec PREFIXPLUS
                        |
                        SUBTRACT expression:e
                        {: RESULT = new UnaryExpression("-", e); :}
                        %prec PREFIXMINUS
                        ;

nameExpression      ::= ID:i
                        {: RESULT = new OperandExpression(i, "id"); :}
                        |
                        ID:i LBRACKET expression:e RBRACKET
                        {: RESULT = new IndexExpression(i, e); :}
                        ;

operandExpression   ::= INTEGER_LITERAL:i
                        {: RESULT = new OperandExpression(i); :}
                        |
                        FLOAT_LITERAL:f
                        {: RESULT = new OperandExpression(f); :}
                        |
                        CHAR_LITERAL:c
                        {: RESULT = new OperandExpression(c, "char"); :}
                        |
                        STRING_LITERAL:s
                        {: RESULT = new OperandExpression(s, "String"); :}
                        |
                        TRUE
                        {: RESULT = new OperandExpression("true", "boolean"); :}
                        |
                        FALSE
                        {: RESULT = new OperandExpression("false", "boolean"); :}
                        ;

callExpression      ::= ID:i LPAREN RPAREN
                        {: RESULT = new CallExpression(i); :}
                        |
                        ID:i LPAREN arguments:a RPAREN
                        {: RESULT = new CallExpression(i, a); :}
                        ;
