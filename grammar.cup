import java_cup.runtime.*;

terminal    SEMI;
terminal    ASSIGN;
terminal    CLASS;
terminal    FINAL;
terminal    INT;
terminal    BOOL;
terminal    CHAR;
terminal    FLOAT;
terminal    VOID;
terminal    TRUE;
terminal    FALSE;
terminal    IF;
terminal    ELSE;
terminal    WHILE;
terminal    READ;
terminal    PRINTLINE;
terminal    PRINT;
terminal    RETURN;
terminal    INCREMENT;
terminal    DECREMENT;
terminal    MULTIPLY;
terminal    DIVIDE;
terminal    ADD;
terminal    SUBTRACT;
terminal    LT;
terminal    GT;
terminal    LTE;
terminal    GTE;
terminal    EQ;
terminal    NE;
terminal    OR;
terminal    AND;
terminal    LPAREN;
terminal    RPAREN;
terminal    LBRACKET;
terminal    RBRACKET;
terminal    LCURLY;
terminal    RCURLY;
terminal    COMPLEMENT;
terminal    QUESTION;
terminal    COLON;
terminal    COMMA;
terminal    PREFIXPLUS;
terminal    PREFIXMINUS;
terminal    TYPECAST;
terminal    TERNARY;

terminal int        INTEGER_LITERAL;
terminal float      FLOAT_LITERAL;
terminal String     CHAR_LITERAL;
terminal String     STRING_LITERAL;
terminal String     ID;

non terminal Program            program;
non terminal MemberDeclerations memberDeclerations;
non terminal FieldList          fieldList;
non terminal Field              fieldDecleration;
non terminal MethodList         methodList;
non terminal Method             methodDecleration;
non terminal StatementList      statements;
non terminal Statement          statement;
non terminal Statement          ifStatement;
non terminal Statement          whileStatement;
non terminal Statement          returnStatement;
non terminal Statement          assignStatement;
non terminal Statement          functionStatement;
non terminal Statement          callStatement;
non terminal Statement          suffixStatement;
non terminal Statement          scopeStatement;
non terminal ElseClause         elseClause;
non terminal Expression         expression; 
non terminal Expression         binaryExpression;
non terminal Expression         unaryExpression;
non terminal Expression         operandExpression;
non terminal Expression         callExpression;
non terminal FunctionList       argumentList;
non terminal FunctionList       readList;
non terminal FunctionList       printList;
non terminal FunctionList       printLineList;
non terminal Name               name;
non terminal Type               type;
non terminal Type               returnType;

precedence right QUESTION, COLON, TERNARY;
precedence left OR;
precedence left AND;
precedence left NE, EQ;
precedence left LT, GT, LTE, GTE;
precedence left ADD, SUBTRACT;
precedence left MULTIPLY, DIVIDE;
precedence left TYPECAST;
precedence right PREFIXPLUS, PREFIXMINUS, COMPLEMENT, INCREMENT, DECREMENT;

program             ::= CLASS ID:i LCURLY memberDeclerations:m
                        {: RESULT = new Program(s); :}
                        ;

memberDeclerations  ::= fieldList:f methodList:m
                        {: RESULT = new MemberDeclerations(f, m):}
                        ;

fieldList           ::= fieldDecleration:f fieldList:ff
                        {: RESULT = ff.prepend(f); :}
                        |
                        {: RESULT = new FieldList(); :}
                        ;

fieldDecleration    ::= FINAL type:t ID:i EQ expression:e SEMI
                        {: RESULT = new Field(t, new Name(i), e, true); :}
                        |
                        type:t ID:i EQ expression:e SEMI
                        {: RESULT = new Field(t, new Name(i), e, false); :}
                        |
                        FINAL type:t ID:i SEMI
                        {: RESULT = new Field(t, new Name(i), true); :}
                        |
                        type:t ID:i SEMI
                        {: RESULT = new Field(t, new Name(i), false); :}
                        |
                        type:t ID:i LBRACKET INTEGER_LITERAL:in RBRACKET SEMI
                        {: RESULT = new Field(t, new Name(i, in), false) :}
                        ;

methodList          ::= methodDecleration:m methodList:mm
                        {: RESULT = mm.prepend(m); :}
                        |
                        {: RESULT = new MethodList(); :}
                        ;

methodDecleration   ::= returnType:t ID:i LPAREN argumentList:a RPAREN LCURLY fieldList:f statements:s RCURLY SEMI
                        {: RESULT = new Method(t, i, a, f, s, true); :}
                        |
                        returnType:t ID:i LPAREN argumentList:a RPAREN LCURLY fieldList:f statements:s RCURLY
                        {: RESULT = new Method(t, i, a, f, s, false); :}
                        ;

statements          ::= statement:s statements:ss
                        {: RESULT = ss.prepend(s); :}
                        |
                        {: RESULT = new StatementList(); :}
                        ;

statement           ::= ifStatement:i
                        {: RESULT = i; :}
                        |
                        whileStatement:w
                        {: RESULT = w; :}
                        |
                        returnStatement:r
                        {: RESULT = r; :}
                        |
                        assignStatement:a
                        {: RESULT = a; :}
                        |
                        functionStatement:f
                        {: RESULT = f; :}
                        |
                        callStatement:c
                        {: RESULT = c; :}
                        |
                        suffixStatement:s
                        {: RESULT = s; :}
                        |
                        scopeStatement:ss
                        {: RESULT = ss; :}
                        ;

ifStatement         ::= IF LPAREN expression:e RPAREN LCURLY statements:s RCURLY elseClause:ec
                        {: RESULT = new IfStatement(e, s, ec); :}
                        ;

whileStatement      ::= WHILE LPAREN expression:e RPAREN LCURLY statements:s RCURLY
                        {: RESULT = new WhileStatement(e, s); :}
                        ;

returnStatement     ::= RETURN expression:e SEMI
                        {: RESULT = new ReturnStatement(e); :}
                        |
                        RETURN SEMI
                        {: RESULT = new ReturnStatement(); :}
                        ;

assignStatement     ::= name:n ASSIGN expression:e SEMI
                        {: RESULT = new AssignmentStatement(n, e); :}
                        ;

functionStatement   ::= READ LPAREN readList:r RPAREN SEMI
                        {: RESULT = new LibraryFunctionStatement("read", r); :}
                        |
                        PRINT LPAREN printList:p RPAREN SEMI
                        {: RESULT = new LibraryFunctionStatement("print", p); :}
                        |
                        PRINTLINE LPAREN printLineList:p RPAREN SEMI
                        {: RESULT = new LibraryFunctionStatement("printline", p); :}
                        ;

callStatement       ::= callExpression:c SEMI
                        {: RESULT = new CallStatement(c); :}
                        ;

suffixStatement     ::= name:n INCREMENT SEMI
                        {: RESULT = new SuffixStatement(n, "++"); :}
                        |
                        name:n DECREMENT SEMI
                        {: RESULT = new SuffixStatement(n, "--"); :}
                        ;

scopeStatement      ::= LCURLY statements:s RCURLY
                        {: RESULT = new ScopeStatement(s, false); :}
                        |
                        LCURLY statements:s RCURLY SEMI
                        {: RESULT = new ScopeStatement(s, true); :}
                        ;

argumentList        ::= expression:e COMMA argumentList:a
                        {: RESULT = a.prepend(e); :}
                        |
                        expression:e
                        {: RESULT = new ArgumentList(e); :}
                        ;

printList           ::= expression:e COMMA printList:p
                        {: RESULT = p.prepend(e); :}
                        |
                        expression:e
                        {: RESULT = new PrintList(e); :}
                        ;

printLineList       ::= printList:p
                        {: RESULT = p; :}
                        |
                        {: RESULT = new PrintList(); :}
                        ;

readList            ::= name:n COMMA readList:r
                        {: RESULT = r.prepend(n); :}
                        |
                        name:n
                        {: RESULT = new ReadList(n); :}
                        ;

elseClause          ::= ELSE LCURLY statements:s RCURLY
                        {: RESULT = new ElseClause(s); :}
                        |
                        {: RESULT = new ElseClause(); :}
                        ;

type                ::= INT
                        {: RESULT = new Type("int"); :}
                        |
                        CHAR
                        {: RESULT = new Type("char"); :}
                        |
                        BOOL
                        {: RESULT = new Type("bool"); :}
                        |
                        FLOAT
                        {: RESULT = new Type("float"); :}
                        ;

returnType          ::= VOID
                        {: RESULT = new Type("void"); :}
                        |
                        type:t
                        {: RESULT = t; :}
                        ;

expression          ::= binaryExpression:b
                        {: RESULT = b; :}
                        |
                        unaryExpression:u
                        {: RESULT = u; :}
                        |
                        name:n
                        {: RESULT = n; :}
                        |
                        operandExpression:o
                        {: RESULT = o; :}
                        |
                        callExpression:c
                        {: RESULT = c; :}
                        |
                        LPAREN expression:e RPAREN
                        {: RESULT = new ParenExpression(e); :}
                        |
                        LPAREN type:t RPAREN expression:e
                        {: RESULT = new CastExpression(t, e); :}
                        %prec TYPECAST
                        |
                        LPAREN expression:e1 QUESTION expression:e2 COLON expression:e3 RPAREN
                        {: RESULT = new TernaryExpression(e1, e2, e3); :}
                        ;

binaryExpression    ::= expression:e1 ADD expression:e2
                        {: RESULT = new BinaryExpression(e1, "+", e2); :}
                        |
                        expression:e1 SUBTRACT expression:e2
                        {: RESULT = new BinaryExpression(e1, "-", e2); :}
                        |
                        expression:e1 MULTIPLY expression:e2
                        {: RESULT = new BinaryExpression(e1, "*", e2); :}
                        |
                        expression:e1 DIVIDE expression:e2
                        {: RESULT = new BinaryExpression(e1, "/", e2); :}
                        |
                        expression:e1 LT expression:e2
                        {: RESULT = new BinaryExpression(e1, "<", e2); :}
                        |
                        expression:e1 GT expression:e2
                        {: RESULT = new BinaryExpression(e1, ">", e2); :}
                        |
                        expression:e1 LTE expression:e2
                        {: RESULT = new BinaryExpression(e1, "<=", e2); :}
                        |
                        expression:e1 GTE expression:e2
                        {: RESULT = new BinaryExpression(e1, ">=", e2); :}
                        |
                        expression:e1 EQ expression:e2
                        {: RESULT = new BinaryExpression(e1, "==", e2); :}
                        |
                        expression:e1 NE expression:e2
                        {: RESULT = new BinaryExpression(e1, "<>", e2); :}
                        |
                        expression:e1 OR expression:e2
                        {: RESULT = new BinaryExpression(e1, "||", e2); :}
                        |
                        expression:e1 AND expression:e2
                        {: RESULT = new BinaryExpression(e1, "&&", e2); :}
                        ;

unaryExpression     ::= COMPLEMENT expression:e
                        {: RESULT = new UnaryExpression("~", e); :}
                        |
                        ADD expression:e
                        {: RESULT = new UnaryExpression("+", e); :}
                        %prec PREFIXPLUS
                        |
                        SUBTRACT expression:e
                        {: RESULT = new UnaryExpression("-", e); :}
                        %prec PREFIXMINUS
                        ;

name                    ::= ID:i
                        {: RESULT = new Name(i); :}
                        |
                        ID:i LBRACKET expression:e RBRACKET
                        {: RESULT = new Name(i, e); :}
                        ;

operandExpression   ::= INTEGER_LITERAL:i
                        {: RESULT = new OperandExpression(i); :}
                        |
                        FLOAT_LITERAL:f
                        {: RESULT = new OperandExpression(f); :}
                        |
                        CHAR_LITERAL:c
                        {: RESULT = new OperandExpression(c, "char"); :}
                        |
                        STRING_LITERAL:s
                        {: RESULT = new OperandExpression(s, "string"); :}
                        |
                        TRUE
                        {: RESULT = new OperandExpression("true", "boolean"); :}
                        |
                        FALSE
                        {: RESULT = new OperandExpression("false", "boolean"); :}
                        ;

callExpression      ::= ID:i LPAREN RPAREN
                        {: RESULT = new CallExpression(i); :}
                        |
                        ID:i LPAREN argumentList:a RPAREN
                        {: RESULT = new CallExpression(i, a); :}
                        ;
